<!-- <script src="require.min.js"></script> -->

<!-- <script src="splitAtDelimiters.js"></script> -->

<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"> -->

<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js"></script> -->

<!-- <script src="auto-render.js"></script> -->

<p><link rel="stylesheet" type="text/css" href="./codehilite.css">
<script>
    renderMathInElement(document.body);
</script>
<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\$','\$']]}
});
</script>
<STYLE type="text/css">
.MathJax .mo { color: inherit; font-weight: inherit }
.Mathjax .hll { color: inherit; font-weight: inherit }
.MathJax .c { color: inherit; font-weight: inherit} 
.MathJax .err { color inherit; font-weight: inherit}
.MathJax    .k { color  : inherit; font-weight: inherit}
.MathJax    .o { color  : inherit; font-weight: inherit}
.MathJax    .cm { color : inherit; font-weight: inherit}
.MathJax    .cp { color : inherit; font-weight: inherit}
.MathJax    .c1 { color : inherit; font-weight: inherit}
.MathJax    .cs { color : inherit; font-weight: inherit}
.MathJax    .gd { color : inherit; font-weight: inherit}
.MathJax    .ge { font-style    : inherit; font-weight: inherit}
.MathJax    .gr { color : inherit; font-weight: inherit}
.MathJax    .gh { color : inherit; font-weight: inherit}
.MathJax    .gi { color : inherit; font-weight: inherit}
.MathJax    .go { color : inherit; font-weight: inherit}
.MathJax    .gp { color : inherit; font-weight: inherit}
.MathJax    .gs { font-weight   : inherit; font-weight: inherit}
.MathJax    .gu { color : inherit; font-weight: inherit}
.MathJax    .gt { color : inherit; font-weight: inherit}
.MathJax    .kc { color : inherit; font-weight: inherit}
.MathJax    .kd { color : inherit; font-weight: inherit}
.MathJax    .kn { color : inherit; font-weight: inherit}
.MathJax    .kp { color : inherit; font-weight: inherit}
.MathJax    .kr { color : inherit; font-weight: inherit}
.MathJax    .kt { color : inherit; font-weight: inherit}
.MathJax    .m { color  : inherit; font-weight: inherit}
.MathJax    .s { background-color   : inherit; font-weight: inherit}
.MathJax    .na { color : inherit; font-weight: inherit}
.MathJax    .nb { color : inherit; font-weight: inherit}
.MathJax    .nc { color : inherit; font-weight: inherit}
.MathJax    .no { color : inherit; font-weight: inherit}
.MathJax    .nd { color : inherit; font-weight: inherit}
.MathJax    .ni { color : inherit; font-weight: inherit}
.MathJax    .ne { color : inherit; font-weight: inherit}
.MathJax    .nf { color : inherit; font-weight: inherit}
.MathJax    .nl { color : inherit; font-weight: inherit}
.MathJax    .nn { color : inherit; font-weight: inherit}
.MathJax    .nt { color : inherit; font-weight: inherit}
.MathJax    .nv { color : inherit; font-weight: inherit}
.MathJax    .ow { color : inherit; font-weight: inherit}
.MathJax    .w { color  : inherit; font-weight: inherit}
.MathJax    .mb { color : inherit; font-weight: inherit}
.MathJax    .mf { color : inherit; font-weight: inherit}
.MathJax    .mh { color : inherit; font-weight: inherit}
.MathJax    .mi { color : inherit; font-weight: inherit}
.MathJax    .mo { color : inherit; font-weight: inherit}
.MathJax    .sb { background-color  : inherit; font-weight: inherit}
.MathJax    .sc { color : inherit; font-weight: inherit}
.MathJax    .sd { color : inherit; font-weight: inherit}
.MathJax    .s2 { background-color  : inherit; font-weight: inherit}
.MathJax    .se { color : inherit; font-weight: inherit}
.MathJax    .sh { background-color  : inherit; font-weight: inherit}
.MathJax    .si { background-color  : inherit; font-weight: inherit}
.MathJax    .sx { color : inherit; font-weight: inherit}
.MathJax    .sr { color : inherit; font-weight: inherit}
.MathJax    .s1 { background-color  : inherit; font-weight: inherit}
.MathJax    .ss { color : inherit; font-weight: inherit}
.MathJax    .bp { color : inherit; font-weight: inherit}
.MathJax    .vc { color : inherit; font-weight: inherit}
.MathJax    .vg { color : inherit; font-weight: inherit}
.MathJax    .vi { color : inherit; font-weight: inherit}
.MathJax    .il { color : inherit; font-weight: inherit}</p>
</STYLE>

<h1>Example of a Lisp macro to implement Newton-Raphson algorithm.</h1>
<p>We introduce two numerical algorithms to solve equations: the
bissection algorithm and the Newton-Raphson algorithm. Newton-Raphson
performs better, and we compare its implementations in a language that
doesn't have Lisp style macros (Python) and one language that has them
(Clojure), to illustrate what macros can do. On the way, the reader
will have learned about numerical algorithms, symbolic derivation,
some elements to write an interpreter, and the Lisp syntax.</p>
<h2>Let's approximate $\sqrt{2}$</h2>
<p>So let's set ourselves to calculate $\sqrt{2}$. It is defined as the
positive solution of $x^2=2$. Since the function $f:x\mapsto x^2$ is
strictly increasing over $\mathbb{R}^+$, the equation $f(x)=2,x\geq 0$
has only one solution, and since $f(1)=1&lt;2$ and $f(2)=4&gt;2$, we know
that this solution is between $1$ and $2$. We now calculate
$f(1.5)=2.25&gt;2$, so we have $1&lt;\sqrt{2}&lt;1.5$. We get a better
approximation by calculating $f(\frac{1+1.5}{2})=f(1.25)=1.5625&lt;2$ so
we know that $1.25&lt;\sqrt{2}&lt;1.5$. We could carry on like that forever,
but it will be faster to write a quick function to do that for us.
Let's do it in Python:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">approx_sqrt_two</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span><span class="n">n_max</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_max</span><span class="p">:</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">candidate_value</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">candidate_value</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">candidate</span>
</pre></div>


<h2>A more generalized method</h2>
<p>The above code works well, but it can't be used to calculate any other
things that $\sqrt{2}$. The first thing we can do is tweak it so it
can calculate the square root of any number:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">approx_sqrt</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span><span class="n">n_max</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span><span class="n">target</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_max</span><span class="p">:</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">candidate_value</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">candidate_value</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">candidate</span>
</pre></div>


<p>So there it is, our new function <code>approx_sqrt</code> can calculate the
square root of any number. In fact we can do even better by enabling
our algorithm to be used for an arbitrary function.</p>
<p>What we want is to have a function with a signature <code>:::python def
approx(func,target,tol=00001,n_max=100)</code> where <code>func</code> will be a lambda
expression. Here is a first try:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">approx</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span><span class="n">n_max</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">candidate_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">candidate_value</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">candidate</span>
</pre></div>


<p>We now need to specify the bounds inside which the solution resides
(the arguments <code>a</code> and <code>b</code>), and also it assumes that <code>func</code> is
increasing (at the line <code>if candidate_value &gt; target:</code>). If we assume
<code>func</code> is monotonic (either always increasing or always decreasing) we
can make a small modification to that code where we guess whether
<code>func</code> is increasing or decreasing, by calculating the rate
$\displaystyle\frac{\text{func}(b)-\text{func}(a)}{b-a}$:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">approx2</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span><span class="n">n_max</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
    <span class="n">compare</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">candidate_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compare</span><span class="p">(</span><span class="n">candidate_value</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">candidate</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">candidate</span>
</pre></div>


<h2>A faster algorithm: Newton-Raphson</h2>
<p>Let us go back to the first problem and see how fast the first
algorithm performs to calculate $\sqrt{2}$. Is that algorithm
efficient? We make a small change in the first version of the code to
return how many iterations it required:</p>
<p>Can we do better? When searching for a better candidate that <code>a</code> and
<code>b</code>, the bisection algorithm takes the value
$\displaystyle\frac{a+b}{2}$. Taking the average is a reasonable
choice but it can seem a bit arbitrary, and that is where lies any
improvement of that algorithm. The algorithm of Newton-Raphson does
just that: it starts with $a$ as a first candidate, and then the
second candidate is calculated by solving:
$f'(a)(x-a)+f(a)=\text{target}$.</p>
<p>Why this formula? $y=f'(a)(x-a)+f(a)$ is the equation of the tangent
in $a$ of the curve defined by $y=f(x)$. Look for a graphical
explanation.</p>
<p>Here is the code for it:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">approx_sqrt_two_nr</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span><span class="n">n_max</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">candidate</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_max</span><span class="p">:</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="n">candidate</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">candidate</span><span class="p">)</span> <span class="o">+</span> <span class="n">candidate</span>
        <span class="n">candidate_value</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">candidate</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">candidate</span><span class="p">,</span><span class="n">n</span>
</pre></div>


<p>[insert graphic here]</p>
<p>The question that remains is: can we change the code to make it take
a lambda argument like we did with the bisection algorithm?</p>
<h2>Generalizing the Newton-Raphson code for any function</h2>
<p>Let us look as what it would take: the Newton-Raphson algorithm
requires to calculate the derivative of $f$, the function we want to
invert, which means taking a function (in our case: <code>x**2</code>) and
applying it a non trivial transformation (in our case it becomes<code>2*x</code>).</p>
<p>It is possible in any language to have a program that calculates
symbolic derivatives. What is harder is to have this integrated with
the rest of the code. Here is some pseudo code to implement
Newton-Raphson in python with the function to solve as an input:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">approx_nr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">candidate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span><span class="n">n_max</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span><span class="o">-</span><span class="n">target</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">derivative_func</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="c">#this is the hard part</span>
    <span class="k">while</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_max</span><span class="p">:</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span><span class="o">-</span><span class="n">func</span><span class="p">(</span><span class="n">candidate</span><span class="p">))</span><span class="o">/</span><span class="n">derivative_func</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span> <span class="o">+</span> <span class="n">candidate</span>
        <span class="n">candidate_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">candidate_value</span><span class="o">-</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">candidate</span><span class="p">,</span><span class="n">n</span>
</pre></div>


<p>The problem lies in the command <code>derivative(func)</code>, which is supposed
to calculate the derivative of func. It is possible to do it with the
numerical derivative, which consists at approximating the quantity
$f'(x)$ with $f'(x) ~
\displaystyle\frac{f(x+\varepsilon)-f(x-\varepsilon)}{2\varepsilon}$
but I want to ignore this possibility as the goal of this article is
to introduce a Lisp macro through symbolic derivative.</p>
<h2>An attempt to do it in Python</h2>
<p>To calculate the symbolic derivative of a function, we need to have
first its expression, which isn't available with a lambda expression.
So we need to introduce a <code>Function</code> object that will contain that:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Function</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">expression</span><span class="p">,</span><span class="n">evaluation</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluation</span> <span class="o">=</span> <span class="n">evaluation</span>
</pre></div>


<h3>Representing a synctactic tree</h3>
<p>The question arises: how to store the function's expression? The
simplest answer, as a string (so <code>x**2</code> would simply become <code>"x**2"</code>)
turns out to be inconvenient to calculate the derivative. Instead it
is much better to store the expression as a direct representation of
the function syntactic tree: </p>
<div class="codehilite"><pre>   &quot;**&quot;
 /      \
</pre></div>


<p>"x"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</p>
<p>This representation shows that the main function is <code>"**"</code> and its two
arguments are <code>"x"</code> and <code>2</code>. One way to represent this
programmatically is to create a class like:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">NodeFunction</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">main</span><span class="p">,</span><span class="n">arguments</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">main</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span> <span class="o">=</span> <span class="n">arguments</span>
</pre></div>


<p>And our expression would become <code>NodeFunction("**",["x",2])</code>. If we
want to represent <code>(x+1)**2</code> the same way, it would become:
<code>NodeFunction("**",[NodeFunction("+",["x",1]),2])</code>.</p>
<p>Another way is to represent our syntactic tree is through a list:
<code>"x**2"</code> becomes <code>["**","x",2]</code>, and <code>"(x+1)**2"</code> becomes
<code>["**",["+","x",1],2]</code>.</p>
<p>Those two ways are equivalent but I will use the latter as it is more
succinct, so I will stick with it for the rest.</p>
<h3>Evaluation of a syntactic tree</h3>
<p>We will need to be able to evaluate a syntactic tree at a given point.
For that we write a function whose signature will <code>evaluate_tree(tree,values)</code> where
<code>values</code> is going to be a dictionary (to allow multiple variables).
For example <code>evaluate_tree(["+",1,"x"],{"x":2})</code> should read
<code>["+",1,"x"]</code>, replace <code>"x"</code> by <code>2</code> when it encounters it, and proceed
the evaluation recursively. If <code>tree</code> is not a list, we will assume
it's either a number, in which case we return it, or a string, in
which case we assume that it is one of the keys of <code>values</code>, and
return its corresponding value.</p>
<p>If <code>tree</code> is a list, we take the main function that is <code>tree[0]</code> and the arguments. We
will evaluate the arguments using <code>evaluate_tree</code> recursively, and
once they are reduced to numbers we will be able to simply apply the
main function to them.</p>
<p>The code will be:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">evaluate_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c">#in that case we assume that tree is a number</span>
            <span class="k">return</span> <span class="n">tree</span>
    <span class="n">main</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">args_evaluated</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">evaluate_tree</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">values</span><span class="p">),</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;+&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args_evaluated</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;-&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">args_evaluated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args_evaluated</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;*&quot;</span><span class="p">:</span>
        <span class="c">#again,assuming only two arguments</span>
        <span class="k">return</span> <span class="n">args_evaluated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">args_evaluated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;/&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">args_evaluated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">args_evaluated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;**&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">args_evaluated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">args_evaluated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c">#for the rest of the function, we assume only one argument</span>
    <span class="c">#the functions log, exp, cos and sin need to be imported</span>
    <span class="c">#from the math module</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;ln&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="n">args_evaluated</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;exp&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="n">args_evaluated</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;cos&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="n">args_evaluated</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;sin&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">args_evaluated</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>This is not the most robust code, but it will fit for illustrative purpose.</p>
<h3>Symbolic derivative</h3>
<p>Let's calculate the derivative of a function! Before that, here is a
reminder of the rules to calculate the derivative:</p>
<p>$\frac{d(f+g)}{dx} = \frac{df}{dx}+\frac{dg}{dx}$</p>
<p>$\frac{d(f-g)}{dx} = \frac{df}{dx} - \frac{dg}{dx}$</p>
<p>$\frac{d(fg)}{dx} = \frac{df}{dx}g + f\frac{dg}{dx}$</p>
<p>$\frac{d(f/g)}{dx} = \frac{\frac{df}{dx}g-f\frac{dg}{dx}}{\big(\frac{dg}{dx}\big)^2}$</p>
<p>$\frac{d(f(g))}{dx} = \frac{dg}{dx}\Big(\frac{df}{dx}\Big)(g)$</p>
<p>And the derivatives of elementary functions:</p>
<p>$\frac{dx}{dx} = 1$</p>
<p>$\frac{dK}{dx} = 0$ &nbsp;&nbsp;&nbsp; If $K$ is a constant (with respect to $x$).</p>
<p>$\frac{dx^n}{dx} = nx^{n-1}$</p>
<p>$\frac{d(\cos x)}{dx} = -\sin x$</p>
<p>$\frac{d(\sin x)}{dx} = \cos x$</p>
<p>$\frac{de^x}{dx} = e^x$</p>
<p>$\frac{d\ln x}{dx} = \frac{1}{x}$</p>
<p>Let's now write a function that calculates the symbolic derivative of
a mathematical expression. We will restrict ourselves to the functions
listed above.</p>
<p>The our function will take a mathematical expression as an argument,
along with the variable we are calculative the derivative with respect
to. So the signature of our function will be
<code>derivative(expr,variable)</code>.</p>
<p>The mechanism to calculate the symbolic derivative of a syntactic tree
is very similar to the mechanism to evaluate a syntactic tree: we go
down the tree, if the tree is a constant or a variable, calculating
the derivative is straightforward (it's $1$ if
the expression is equal to the variable, and $0$ otherwise).
So the start of the function will look like:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="n">variable</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">variable</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">main</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="o">...</span>
</pre></div>


<p>If the tree is a list, the code will break down the expression into the main
function (the first element of the list) and its arguments (the rest
of the list). 
Then we will check what is the value of <code>main</code> and apply the
corresponding formula to the arguments. For example, if <code>main</code> is
<code>"+"</code>, it will look like:</p>
<div class="codehilite"><pre><span class="n">derivative_args</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">variable</span><span class="p">),</span><span class="n">args</span><span class="p">)</span>
<span class="k">return</span> <span class="p">[</span><span class="s">&quot;+&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">derivative_args</span>
</pre></div>


<p>For the other possible values of <code>main</code> we will apply the rules of the
derivation that we saw above.</p>
<p>At the end the whole function is:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="n">variable</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">variable</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">main</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;+&quot;</span><span class="p">:</span>
        <span class="n">derivative_args</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">variable</span><span class="p">),</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;+&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">derivative_args</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;*&quot;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c">#assume there are only two arguments</span>
        <span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">variable</span><span class="p">),</span> <span class="n">derivative</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;+&quot;</span><span class="p">,[</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">du</span><span class="p">,</span><span class="n">v</span><span class="p">],[</span><span class="n">u</span><span class="p">,</span><span class="n">dv</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;/&quot;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c">#assume there are only two arguments</span>
        <span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">variable</span><span class="p">),</span> <span class="n">derivative</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">,[</span><span class="s">&quot;-&quot;</span><span class="p">,[</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">du</span><span class="p">,</span><span class="n">v</span><span class="p">],[</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">dv</span><span class="p">]],[</span><span class="s">&quot;**&quot;</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;**&quot;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c">#assume there are only two arguments</span>
        <span class="n">du</span><span class="p">,</span> <span class="n">dv</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">variable</span><span class="p">),</span> <span class="n">derivative</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;*&quot;</span><span class="p">,[</span><span class="s">&quot;+&quot;</span><span class="p">,</span><span class="n">dv</span><span class="p">,[</span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="n">du</span><span class="p">,</span><span class="n">u</span><span class="p">]],[</span><span class="s">&quot;**&quot;</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;exp&quot;</span><span class="p">:</span> <span class="c">#exponential function</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#assume one argument only</span>
        <span class="n">du</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">du</span><span class="p">,[</span><span class="s">&quot;exp&quot;</span><span class="p">,</span><span class="n">u</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;ln&quot;</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#assume one argument only</span>
        <span class="n">du</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="n">du</span><span class="p">,</span><span class="n">u</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;cos&quot;</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#assume one argument only</span>
        <span class="n">du</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">du</span><span class="p">,[</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,[</span><span class="s">&quot;sin&quot;</span><span class="p">,</span><span class="n">u</span><span class="p">]]]</span>
    <span class="k">if</span> <span class="n">main</span> <span class="o">==</span> <span class="s">&quot;sin&quot;</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#assume one argument only</span>
        <span class="n">du</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">du</span><span class="p">,[</span><span class="s">&quot;cos&quot;</span><span class="p">,</span><span class="n">u</span><span class="p">]]</span>
    <span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>Again, this is not the most robust code and has some defaults (for example,
the multiplication can only take two arguments) but it is simple and
illustrates how symbolic derivatives are calculated.</p>
<h3>Complete implementation of Newton-Raphson</h3>
<p>What remains is now to integrate the <code>derivative</code> function with the
rest of the code. It requires a small modification of the prototype
code we wrote in a previous paragraph (func is gonna be a <code>Function</code>
object that was described above):</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">approx_nr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">candidate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span><span class="n">n_max</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span><span class="o">-</span><span class="n">target</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">derivative_func</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">expression</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_max</span><span class="p">:</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span><span class="o">-</span><span class="n">func</span><span class="p">(</span><span class="n">candidate</span><span class="p">))</span><span class="o">/</span><span class="n">evaluate_tree</span><span class="p">(</span><span class="n">derivative_func</span><span class="p">,{</span><span class="s">&quot;x&quot;</span><span class="p">:</span><span class="n">candidate</span><span class="p">})</span> <span class="o">+</span> <span class="n">candidate</span>
        <span class="n">candidate_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">candidate_value</span><span class="o">-</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">candidate</span><span class="p">,</span><span class="n">n</span>
</pre></div>


<h2>A Lisp version with a macro</h2>
<h3>Brief description of the Lisp syntax</h3>
<p>The Lisp syntax is different of most language: instead of having
<code>function(arg1,arg2)</code>, lisp is <code>(function arg1 arg2)</code>. The operators
don't have a special syntax, so for example <code>1+2*(3-4)</code> is <code>(+ 1 (* 2
(- 3 4)))</code>. Please notice that it is very similar to how we expressed
the syntactic tree earlier.</p>
<p>Since the rest of the code in the article is going to be in Clojure, I
will give a brief overview of the Clojure syntax. Feel free to skip if
you're already familiar with this language.</p>
<h4>Variable assignments</h4>
<p>Global variables are defined using <code>def</code>. For example:</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>
<span class="nv">user=&gt;</span> <span class="nv">x</span>
<span class="mi">4</span>
</pre></div>


<h4>Local variables</h4>
<p>Local variables are defined using <code>let</code>. For example:</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">5</span><span class="p">]</span>
<span class="o">#</span><span class="nv">_=&gt;</span>    <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">10</span>
</pre></div>


<p>Inside this <code>let</code> is defined the variable <code>x</code> equal to 5. We then
calculate <code>(* 2 x)</code>.</p>
<p><code>let</code>'s can be used to define multiple variables at the same time,
some depending of the previous ones:</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">1</span>
<span class="o">#</span><span class="nv">_=&gt;</span>       <span class="nv">y</span> <span class="mi">2</span>
<span class="o">#</span><span class="nv">_=&gt;</span>       <span class="nv">z</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)]</span>
<span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">z</span><span class="p">))</span>
<span class="mi">6</span>
</pre></div>


<h4>Anonymous functions</h4>
<p>Clojure can also take anonymous functions, they can be expressed in
two ways: <code>#(+ 1 %)</code> (<code>%</code> is the argument, if there are multiple
arguments it becomes <code>#(+ 1 %1 %2)</code>), or using <code>fn</code>: <code>(fn [x] (+ 1
x))</code>.</p>
<p>Anonymous functions are called just like standard functions, except
that instead of their names, it's their full codes that is given:</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">x</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">6</span>
</pre></div>


<h4>Function definition</h4>
<p>A function is created using <code>defn</code>. For example:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">my-function</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>


<p><code>defn</code> can also be used to define several times the function with
different arguments:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">my-other-function</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
        <span class="p">(</span><span class="nf">my-other-function</span> <span class="p">[</span><span class="nv">x</span> <span class="mi">2</span><span class="p">])</span>
      <span class="nv">my-other-function</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
        <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>


<p>That was <code>my-other-function</code> can take either one or two arguments.</p>
<p>It is also possible to use <code>def</code> to define a function:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="k">def </span><span class="nv">yet-another-function</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>


<h4>Lists and Vectors</h4>
<p>In Clojure, vectors are between brackets: <code>[1, 2, 3]</code> and lists are
between parenthesis, but they are quoted so they are not evaluated:
<code>'(1 2 3)</code>. The function to get an element of a list is <code>nth</code>:</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>
</pre></div>


<p>It is very common to want to access to the first element of a list,
and also to the rest of the elements of that list. For that two
functions exist: <code>first</code> and <code>rest</code>:</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="mi">1</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rest </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>


<p>Clojure data are immutable, so lists can't be modified. However, it is
possible to construct a new list from a list and a new element, where
the new element is put at the beginning of the new list, with the function
<code>cons</code>:</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<h4>Conditions</h4>
<p>Like in most of the programming languages, Clojure has <code>if</code>
conditions, that takes a boolean, a value to return if the boolean is
true and another value to return otherwise.</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
</pre></div>


<p>There is also a switch statement called <code>cond</code> to test several
conditions on data. <code>cond</code> has to contain a default case, named
`:default':</p>
<div class="codehilite"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">show-cond</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="o">#</span><span class="nv">_=&gt;</span>      <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&quot;negative&quot;</span>
<span class="o">#</span><span class="nv">_=&gt;</span>            <span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span> <span class="s">&quot;small&quot;</span>
<span class="o">#</span><span class="nv">_=&gt;</span>            <span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="mi">100</span><span class="p">)</span> <span class="s">&quot;normal&quot;</span>
<span class="o">#</span><span class="nv">_=&gt;</span>            <span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="mi">1000</span><span class="p">)</span> <span class="s">&quot;big&quot;</span>
<span class="o">#</span><span class="nv">_=&gt;</span>            <span class="ss">:default</span> <span class="s">&quot;really big&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/show-cond</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">show-cond</span> <span class="mi">100000</span><span class="p">)</span>
<span class="s">&quot;really big&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">show-cond</span> <span class="mi">-1</span><span class="p">)</span>
<span class="s">&quot;negative&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">show-cond</span> <span class="mi">5</span><span class="p">)</span>
<span class="s">&quot;small&quot;</span>
</pre></div>


<h4>Recursion and loops</h4>
<p>For performance issues, recursions are done with <code>recur</code>.</p>
<div class="codehilite"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">my-sum</span> <span class="p">[</span><span class="nv">a-list</span><span class="p">]</span>
         <span class="p">(</span><span class="nf">my-sum</span> <span class="nv">a-list</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">my-sum</span> <span class="p">[</span><span class="nv">a-list</span> <span class="nv">pre-sum</span><span class="p">]</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">nil? </span><span class="nv">a-list</span><span class="p">)</span> <span class="mi">0</span>
             <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">first </span><span class="nv">a-list</span><span class="p">)</span>
                   <span class="nv">xs</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">a-list</span><span class="p">)]</span>
               <span class="p">(</span><span class="nf">recur</span> <span class="nv">xs</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">pre-sum</span> <span class="nv">x</span><span class="p">)))))</span>
</pre></div>


<p>Loops also work with <code>recur</code>, here is an example</p>
<div class="codehilite"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">my-other-sum</span> <span class="p">[</span><span class="nv">a-list</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">loop</span> <span class="p">[</span><span class="nv">res</span> <span class="mi">0</span>
           <span class="nv">lst</span> <span class="nv">a-list</span><span class="p">]</span>
       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">nil?</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">res</span>
           <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="k">first </span><span class="nv">a-list</span><span class="p">)</span>
                 <span class="nv">xs</span> <span class="p">(</span><span class="k">rest </span><span class="nv">a-list</span><span class="p">)]</span>
             <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">res</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">xs</span><span class="p">)))))</span>
</pre></div>


<h3>Lisp macros</h3>
<p>Macros can be seen as special functions that enable the programmer to
modify the syntax of the language. How? By controlling how the
arguments are getting evaluated. Is that an helpful explanation?
Probably not but I hope to be able to shed some light soon by giving
an example of a concrete macro.</p>
<h3>Lisp version of Newton-Raphson</h3>
<h4>Trying to reproduce the Python code</h4>
<p>The python code above for Newton-Raphson can easily be translated into
Clojure.</p>
<p>First, the derivative:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">derivative</span> <span class="p">[</span><span class="nv">function</span> <span class="nv">variable</span><span class="p">]</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">seq </span><span class="nv">function</span><span class="p">))</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">function</span> <span class="nv">variable</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">main</span> <span class="p">(</span><span class="nb">first </span><span class="nv">function</span><span class="p">)</span>
              <span class="nv">args</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">function</span><span class="p">)</span>
              <span class="nv">der</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">derivative</span> <span class="nv">x</span> <span class="nv">variable</span><span class="p">))]</span>
          <span class="p">(</span><span class="nf">cond</span>
            <span class="p">(</span><span class="nb">= </span><span class="ss">&#39;+</span> <span class="nv">main</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;+</span> <span class="p">(</span><span class="nb">map </span><span class="nv">der</span> <span class="nv">args</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">= </span><span class="ss">&#39;-</span> <span class="nv">main</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;-</span> <span class="p">(</span><span class="nb">map </span><span class="nv">der</span> <span class="nv">args</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">= </span><span class="ss">&#39;*</span> <span class="nv">main</span><span class="p">)</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">u</span> <span class="p">(</span><span class="nb">get </span><span class="mi">0</span> <span class="nv">args</span><span class="p">)</span>
                              <span class="nv">du</span> <span class="p">(</span><span class="nf">der</span> <span class="nv">u</span><span class="p">)</span>
                              <span class="nv">v</span> <span class="p">(</span><span class="nb">get </span><span class="mi">1</span> <span class="nv">args</span><span class="p">)</span>
                              <span class="nv">dv</span> <span class="p">(</span><span class="nf">der</span> <span class="nv">v</span><span class="p">)]</span>
                          <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;+</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;*</span> <span class="nv">u</span> <span class="nv">dv</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;*</span> <span class="nv">v</span> <span class="nv">du</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">= </span><span class="ss">&#39;/</span> <span class="nv">main</span><span class="p">)</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">u</span> <span class="p">(</span><span class="nb">get </span><span class="mi">0</span> <span class="nv">args</span><span class="p">)</span>
                              <span class="nv">du</span> <span class="p">(</span><span class="nf">der</span> <span class="nv">u</span><span class="p">)</span>
                              <span class="nv">v</span> <span class="p">(</span><span class="nb">get </span><span class="mi">1</span> <span class="nv">args</span><span class="p">)</span>
                              <span class="nv">dv</span> <span class="p">(</span><span class="nf">der</span> <span class="nv">v</span><span class="p">)]</span>
                          <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;/</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;-</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;*</span> <span class="nv">du</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="nf">list</span>
<span class="ss">&#39;*</span> <span class="nv">u</span> <span class="nv">dv</span><span class="p">))</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;**</span> <span class="nv">v</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">= </span><span class="ss">&#39;**</span> <span class="nv">main</span><span class="p">)</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">u</span> <span class="p">(</span><span class="nb">get </span><span class="mi">0</span> <span class="nv">args</span><span class="p">)</span>
                               <span class="nv">du</span> <span class="p">(</span><span class="nf">der</span> <span class="nv">u</span><span class="p">)</span>
                               <span class="nv">v</span> <span class="p">(</span><span class="nb">get </span><span class="mi">1</span> <span class="nv">args</span><span class="p">)</span>
                               <span class="nv">dv</span> <span class="p">(</span><span class="nf">der</span> <span class="nv">v</span><span class="p">)]</span>
                           <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;*</span> <span class="nv">du</span> <span class="nv">something</span><span class="p">))))))</span>
<span class="c1">;;TODO: finish that code</span>
</pre></div>


<p>We can then do exactly the same as in Python and write a function
<code>approx-nr</code> whose signature will be <code>(defn approx-nr
[function syntactic-tree target tolerance min-val max-val])</code> that will be
called like: <code>(approx-nr (fn [x] (** x 2)) '(** 2 x) 2 0.00001 1 2)</code>.
But since the two arguments <code>function</code> and <code>syntactic-tree</code> are very
closed (<code>syntactic-tree</code> is, after all, the syntactic tree of
<code>function</code>, and with the Lisp syntax the code of a function is its
syntactic tree...) it is a legitimate concern to want to avoid using
an extra argument and get the syntactic tree directly from <code>function</code>.</p>
<h4>Getting the code of an anonymous function</h4>
<p>For that, we would have to tell the compiler something in the line of
"Hey, do not evaluate
[I don't know if the best term for that is 'evaluate' or 'byte compile'
or 'interpret'] <code>function</code> directly, but before that give me its
source code so I can calculate its derivative!" This is not possible
with a standard function - we don't have control when arguments are
evaluated, but with a macro, it is: here is a macro that extracts the
source code of an anonymous function: <code>(defmacro get-code [func] (list
'quote (nth func 2)))</code></p>
<p>First let's see how it works in the Clojure interpreter:</p>
<div class="codehilite"><pre>user=&gt; (get-code (fn [x] (+ 1 x)))
(+ 1 x)
</pre></div>


<p>How did that work? when calling <code>get-code</code>, <code>func</code> is replaced by the
value we gave it, in our case <code>(fn [x] (+ 1 x))</code>, but it is not
evaluated. That is not the case with functions, so a language like
Python that doesn't have macros can't do that. Then, <code>(fn [x] (+ 1
x))</code> is treated as a normal list, so <code>(nth func 2)</code> returns the 3rd
value in that list, in our case <code>(+ 1 x)</code>. The <code>quote</code> in <code>get-code</code>
is here to say "ok, treat that as a list instead of trying to evaluate
it". The symbol <code>'</code> before the <code>quote</code> is here to tell the clojure
compiler not to eval <code>quote</code> right away.</p>
<p>We can see how the <code>get-code</code> macro is expanded, using <code>macroexpand</code>:</p>
<div class="codehilite"><pre>user=&gt; (macroexpand &#39;(get-code (fn [x] (+ 1 x))))
(quote (+ 1 x))
</pre></div>


<p>Then that last line <code>(quote (+ 1 x))</code> is evaluated and at the end it
returns the list <code>(+ 1 x)</code>.</p>
<h4>Clojure implementation of Newton-Raphson</h4>
<p>We can get the variables names of a function the same way we got its
code. For the sake of conciseness I gonna assume the functions here only
have one variable, so the code to get that variable name is: <code>(defmacro get-variable [func] (list 'quote (nth (nth func 1) 0)))</code>.</p>
<p>Armed with those two utility macros and the <code>derivative</code> function we
are able to write the code for the Newton-Raphson algorithm:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">approx-nr</span>
    <span class="p">([</span><span class="nv">func</span> <span class="nv">target</span><span class="p">]</span> <span class="p">(</span><span class="nf">approx-nr</span> <span class="nv">func</span> <span class="nv">target</span> <span class="nv">start</span> <span class="mf">0.00000001</span> <span class="mi">100</span><span class="p">))</span>
    <span class="p">([</span><span class="nv">func</span> <span class="nv">target</span> <span class="nv">start</span> <span class="nv">tolerance</span> <span class="nv">n-iterations</span><span class="p">]</span>
        <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">variable</span> <span class="p">(</span><span class="nf">get-variable</span> <span class="nv">func</span><span class="p">)</span>
              <span class="nv">code</span> <span class="p">(</span><span class="nf">get-code</span> <span class="nv">func</span><span class="p">)</span>
              <span class="nv">der</span> <span class="p">(</span><span class="nf">derivative</span> <span class="nv">code</span> <span class="nv">variable</span><span class="p">)]</span>
          <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">k</span> <span class="mi">0</span>
                 <span class="nv">res</span> <span class="nv">start</span><span class="p">]</span>
              <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">or</span>
                     <span class="p">(</span><span class="nb">&gt;= </span><span class="nv">k</span> <span class="nv">n-iterations</span><span class="p">)</span>
                     <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">Math/abs</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">func</span> <span class="nv">res</span><span class="p">)</span> <span class="nv">target</span><span class="p">))</span> <span class="nv">tolerance</span><span class="p">))</span>
                 <span class="nv">res</span>
                 <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">k</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">res</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="nv">target</span> <span class="p">(</span><span class="nf">func</span> <span class="nv">res</span><span class="p">))</span> <span class="p">(</span><span class="nf">der</span> <span class="nv">res</span><span class="p">)))))))))</span>
</pre></div>


<p>The main difference with the Python version is that we don't need to
pass the syntactic tree of <code>func</code> to our algorithm since it is
extracted directly from <code>func</code>'s code.</p>
<h3>For a conclusion...</h3>
<p>The python version of the Newton-Raphson algorithm required to
implement a function <code>eval_tree</code> that can evaluate a syntactic tree,
which is basically a small subset of a Lisp interpreter. The Lisp
version doesn't need that, which makes the code shorter as a result,
and also safer as it is not possible to pass to the Newton-Raphson
algorithm  a wrong syntactic tree for the function we are trying to solve.</p>
<p>Instead, we have embedded in our code a very small Computer Algebra
System that operates directly on the code we use. This would not have
been possible without macros. The Lisp guru and evangelist Paul Graham
wrote: "It
would be convenient here if I could give an example of a powerful
macro, and say there! how about that? But if I did, it would just look
like gibberish to someone who didn't know Lisp; there isn't room here
to explain everything you'd need to know to understand what it meant.
In Ansi Common Lisp I tried to move things along as fast as I could,
and even so I didn't get to macros until page 160." [0] Here we
managed to give an example of a powerful macro in much less than 160
pages.</p>
<p>However, the goal for which we had use of macros, numerically solving
arbitrary equations, isn't the most common task in programming, and I
believe this is for this reasons we had to use a macro: if it was
something people did a lot, the functionalities to calculate
derivatives of anonymous functions would have been incorporated to 
popular languages.</p>
<p>Thus macros are useful for greenfield projects, and once such projects
become mainstream functionalities provided by macros get put into
mainstream languages.</p>
<p>[0] http://paulgraham.com/avg.html</p>